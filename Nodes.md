Общие соображения по построению деревьев решений
====

- Всякое дерево начинается с начального узла и должно заканчиваться либо успехом (зелёный узел — "Истина"), либо ошибкой (красный узел — "Ложь").
- В середине дерева могут быть использованы узлы: "Действие" ("найти и задать переменную"), "Вопрос" (развилка по Да/Нет или Enum) или более сложные агрегирующие узлы ("Логический",  "Независимое ветвление", "Цикл"), имеющие своими ветвями под-деревья (маленькие полноценные деревья).
- Сложные (агрегирующие) узлы обязаны иметь все логические выходы (их можно направить сразу в конечные узлы — "Истину" и "Ложь").
- Узлы соединяются между собой стрелками в прямом направлении. Кольца (возвраты на более ранний узел) недопустимы.
  - Обычно у каждого узла (кроме начального) только один вход (т.к. это именно дерево); до недавнего времени акциклические "циклы" в графе определялись как ошибка, препятствуя экспорту дерева. На практике возможно сводить некоторые ветви вместе с целью избежания визуального дублирования узлов (при экспорте в XML они продублируются всё равно, создавая настоящее дерево).

### Специальные объекты на диаграмме
- Все узлы должны быть специальными (созданными или конвертированными через меню плагина), в противном случае они не существуют для дерева.
  - После создания / конвертации узла из существующего для него необходимо задать выражение через меню _Изменить_ > _Изменить значение_.
  - Текстовая надпись на специальном узле может быть отредактирована только через  меню _Изменить_ > _Изменить текстовое значение узла_. Она не используется при интерпретации дерева и служит исключительно для иллюстративных и документирующих целей.
- Стрелки также должны быть аккуратно привязаны к паре узлов каждая и иметь спец. значение по смыслу. Стрелки не должны "висеть" или быть прицепленными к контуру узла.
  - Стрелки создаются обычным методом протягивания от узла к узлу (при необходимости тип линии меняется на прямую).
  - Спец. назначаются значения стрелкам через меню _Изменить_ > _Изменить значение_, и после нажатия на кнопку "_Сохранить_" стрелка становится специальной. При принудительном изменении свойств такой стрелки через разблокирование её можно вернуть в специльное состояние при помощи повторного нажатия той же кнопки.



Описание узлов, доступных в редакторе деревьев
====
✔ — доступно, × — недоступно

## Начальный узел
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/8d4d5e16-83cc-4488-b20b-b4f5fd6cbb92)

| Значение узла | Текст узла | Информация для вопросов |
|---------------------------|:----:|:---:|
| [переменная — её тип]*    | ×    | ×  |

Задаёт начальные (входные) переменные для дерева решений.  
Важно!  
Выходящая из этого узла стрелка должна быть специальной и иметь иметь тип `bool`, a не `object` или что-нибудь другое. (Применительно к интерпретатору дерева: "Пока что поддерживаются только ветки типа Boolean".)


## Узел "Истина / Ложь"
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/600a1538-9810-4241-a9c8-bff0d002e67e)

| Значение узла | Текст узла | Информация для вопросов |
|---------------------------|:----:|:---:|
| Произвольный текст (ризонером не используется)  | ✔    | ×  |

Конечный узел дерева: зелёный узел — "Истина", красный узел — "Ложь".  
Видимый текст и выражение этого узла не принимают непосредственного участия в рассуждении по дереву, но могут быть использованы при анализе результатов выполнения дерева (например, при формировании сообщений для учащегося).  
Любая ветвь дерева должна завершаться таким узлом (за исключением вложенных ветвей "Независимого ветвления", где допустим также результат "Неопределенность").


## Логический узел
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/1947e15a-d566-4742-bb8c-308393e191d3)

| Значение узла | Текст узла | Информация для вопросов |
|---------------------------|:----:|:---:|
| выбор: AND / OR — тип логической операции   | ×    | ✔  |

"Логическая агрегация" представляет собой развилку процесса рассуждений в зависимости от выполнения логической операции (ИЛИ или И) над результатами нескольких подзадач.  
Смысл состоит в декомпозиции некоторой сложной задачи на независимые ветви вычислений и сведении их результатов в один общий.  
Ветви выполняются все, вне зависимости от результатов других ветвей (_не_ ленивое вычисление).

Предполагает наличие выходящих стрелок следующих видов:  
1) ThoughtBranch (произвольное количество) — ветви рассуждений, агрегируемые в данном узле.  
2) Outcome (кол-во 2) — переходы к следующим узлам в зависимости от результата агрегации (значения атрибутов value равны true и false соответственно).


## Узел "Независимое ветвление"
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/79593a46-458c-45a0-a0c3-dc87d282a326)

| Значение узла | Текст узла | Информация для вопросов |
|---------------------------|:----:|:---:|
| (По сути, только текст узла ?)   | ×    | ✔  |

Представляет собой развилку процесса рассуждений, при которой некоторые рассуждения могут «предрешить» результат подзадачи, а потому должны быть выполнены первыми.  

Другое рабочее название узла — "Предрешающие факторы".  
Логика узла в том, что есть несколько веток, из которых только одна может дать результат. Каждая из веток может прийти в Истину, Ложь или Неопределенность (см. ниже). Если ветка закончилась как Неопределенность, то проверяются другие ветки (порядок проверки веток неопределён).  
У каждой ветки predeterminingBranch обязательно должен быть хотя бы один серый узел (иначе зачем вообще Использовать Независимое ветвление в этом случае?).
Узел напоминает ленивый "OR". Однако, в отличие логического узла, этот узел не имеет логического выхода, а только опциональный _undetermined_, который используется в том случае, когда все ветки разрешились в Неопределенность.


## Узел "Неопределенность"
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/5d228dad-262f-44c4-831e-64b066c968d2)
| Значение узла | Текст узла | Информация для вопросов |
|:---:|:----:|:---:|
| ×   | ×    | ×   |

Серый узел — "Неопределенность".  
Третий вариант исхода для веток "Независимого ветвления", когда однозначного решения нет, и нужно продолжать выполнять другие ветви.


## Узел действия
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/17956830-7f0b-4be1-a92a-e2cc7118cc50)

| Значение узла | Текст узла | Информация для вопросов |
|------------------------------------------|:----:|:---:|
| Выражение, выходная переменная и её тип  | ✔    | ✔  |

Используется, чтобы найти объект и задать переменную, которая будет доступна дальнейшим узлам.  
При создании узла действия должно быть задано имя переменной, которая инициализируется в данном узле, тип переменной и выражение для данного узла.

## Узел "Цикл"
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/e144c5f5-d86d-449b-ad8c-6c7ac0dcf70f)

| Значение узла | Текст узла | Информация для вопросов |
|----------------------------------------------------|:----:|:---:|
| Выражение, новая переменная дерева, её тип и режим AND/OR | ✔    | ✔  |

Узел цикла представляет собой развилку процесса рассуждений в зависимости от выполнения логической операции (ИЛИ или И) над
результатами нескольких итераций некоторой подзадачи, выполненной над разными сущностями.  
Выражение в узле определяет множество перебираемых объектов и должно быть истинным для них (и только для них).

При создании узла цикла должно быть задано имя переменной, которая инициализируется в данном узле, тип переменной, оператор (and или or) и выражение для данного узла.

Предполагает наличие выходящих стрелок следующих видов:  
1) ThoughtBranch — агрегируемая ветвь рассуждений цикла, рассматриваемая для разных значений переменной-параметра.
2) Outcome (ровно 2) — переходы к следующим узлам в зависимости от результата агрегации (значения атрибутов value равны true и false соответственно).
 
**Важно**!
При написании выражения для узла "Цикл" новая переменная цикла **должна** записываться без префиксов `var:` и `$`, т.е., к примеру, просто `M`, а не `var:M` и не `$M`: 
- На уровне узла цикла она _ещё НЕ_ является переменной дерева решений; с префиксом `var:` её необходимо использовать в рамках ветви _Body_ (тела) цикла.
  


## Узел вопроса
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/8c8c2320-0403-4fa6-b411-b8a28bf37c2f)

| Значение узла | Текст узла | Информация для вопросов |
|------------------|:----:|:---:|
| Выражение | ✔    | ✔  |

Развилка по Да/Нет или значениям перечисления (Enum), в зависимости от типа выражения в узле. Возможные результаты проверки задаются на выходящих стрелках.  
Для логической (булевой) развилки можно использовать проверки (операции семейства _check_), либо непосредственно значения типа Boolean.   
Для развилки по Enum выражение должно вернуть значение типа Enum; в этом случае на выходящих стрелках нужно использовать значения из этого Enum (редактор сам их предложит).


## Узел "Switch case"
![image](https://github.com/den1s0v/decision-tree-interface/assets/42928670/b0bb6108-1444-445f-b686-7824b1cf8ca3)

| Значение узла | Текст узла | Информация для вопросов |
|------------------|:----:|:---:|
| Выражение | ✔    | ✔  |

Судя по описанию в документации, этот узел — разновидность Вопроса. 

-----
✔ — доступно, × — недоступно

# Рекомендации по устранению проблем

Ниже описанные рекомендации:
 - применимы к онлайн редактору (м.б. неприменимы к настольной Draw.io),
 - основаны на опыте использования и могут иметь более адекватные альтернативные способы решения.

### Редактирование заблокированной стрелки

Проблема: В текущей версии редактора (12.2023) после назначения стрелке специального значения она блокируется, из-за чего невозможно перенаправить её на другой узел или даже просто изменить её форму.  
Решение:
1. **Разблокировать** стрелку на правой панели "Формат" или через контекстное меню стрелки.
2. После этого можно изменять форму стрелки и перецеплять её к нужным узлам.
3. После завершения ручных манипуляций со стрелкой необходимо **актуализировать** её специальное состояние — повторить,  как обычно: выделив стрелку, меню _Изменить_ > _Изменить значение_ > _Сохранить_, после чего стрелка снова заблокируется.


### Удаление неразблокируемой стрелки

Проблема: В текущей версии редактора (12.2023) стрелки иногда не хотят разблокироваться, из-за чего их невозможно отредактировать и просто удалить.  
Решение:
1. Выбрать стрелку и выбрать меню _Конвертация узлов_ > _Конвертировать в..._ (выбрать любой вариант).
2. После этого стрелка удалится, но вместо неё в координатах (0,0) появится текст с типом выбранного узла (оно всё-таки сконвертируется!).
3. Разблокировать и удалить автоматически созданный пустой узел из координат (0,0).


### Недавно внесённые изменения в узлах сбрасываются

Проблема: после редактирования выражения либо текста узла и нажатия кнопки _Сохранить_ через некоторое время (3..10 секунд) отредактированное значение сбрасывается в предыдущее состояние.  
(Это поведение наблюдалось в онлайн-редакторе с размещением документа на Google-диске, а интервал сбрасывания зависел от скорости Интернета.)

Анализ:
- Редактирование данных узла само по себе не инициирует сохранение документа, а инициирует его "обыкновенное" действие над элементами диаграммы: перемещение / изменение размера.
- Если отредактировать значение узла и сразу же (в течение 2-3 секунд) сдвинуть любой элемент либо изменить его размер, то начинается сохранение документа, и изменения в узле сохраняются.

Решение (2 варианта):
1) Сразу после нажатия кнопки _Сохранить_ немного сдвигать текущий узел при помощи однократного нажатия на одну из четырёх стрелок на клавиатуре (⇅ ⇆), при этом для нажатия стрелки не обязательно дожидаться исчезновения модального окна редактирования узла дерева.
2) Или: иметь в области обзора вспомогательный объект диаграммы (не относящийся к дереву), который нужно "дёргать" каждый раз после сохранения значения в очередном отредактированном узле.
  

